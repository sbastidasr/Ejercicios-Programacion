package com.example.junit;
import static org.junit.Assert.*;
import org.junit.Before;

public class EjsTest {

    private Ejs ejs;

    @Before
    public void setUp() throws Exception{
        ejs =new Ejs();
    }

    /*
    1. Let’s start …
    Look at this series: 7, 6, 8, 4, 9, 2, 10, 0, 11, -2, …
    Create a function that receives two integers: x and y. If any of them are 0 or negative, or if
    they are greater than 255, the function should return -1
    Otherwise, the function should return the sum of the x and y elements of the series.
    For example: If the function receives x=1, y=3, it should return: 15. (Because the sum of the
    first plus the third argument is 7+8=15). If the function receives x=8, y=9, it should return 11.
            (Because the sum of the 8th plus the 9th element is 0+11=11).
    The function will receive 2 integers, return an integer
    */
    @org.junit.Test
    public void testEjercicio1() throws Exception {
        assertEquals(-1, ejs.ejercicio1(-1, 3));  //negativo -1
        assertEquals(-1, ejs.ejercicio1(1, 256));  //mayor a 255
        assertEquals(15, ejs.ejercicio1(1, 3));
        assertEquals(11, ejs.ejercicio1(6, 5));
        assertEquals(9, ejs.ejercicio1(9, 10));
    }

    /*2. Wow, this will be easy....
    Look at this series: 2, 2, 4, 12, 48, … the seed for this series was the number 2.
    Look at this series: 3, 3, 6, 18, 72, … the seed for this series was the number 3.
    Create a function that receives two integers: x, and y. If any of them are 0 or negative, or if
    they are greater than 255, the function should return -1
    The function should return the y element of the series generated by x.
    For example, if the series receives x = 3, y = 4, it should return 72, because 72 is the 4th
    element of the series generated when x = 3.
    The function will receive 2 integers, and return an integer*/
    @org.junit.Test
    public void testEjercicio2() throws Exception {
        assertEquals(-1, ejs.ejercicio2a(-1, 4));  //negativo -1
        assertEquals(-1, ejs.ejercicio2a(-1, 256)); //mayor a 255
        assertEquals(3, ejs.ejercicio2a(3, 1));
        assertEquals(6, ejs.ejercicio2a(3, 2));
        assertEquals(72, ejs.ejercicio2a(3, 4));
        assertEquals(48, ejs.ejercicio2a(2, 4));
        assertEquals(4, ejs.ejercicio2a(2, 2));
        //2a mio
        //2 lore
    }
    /*
    3. That was pretty easy, give me another...
    Look at this series: 60, 30, 20, 15, 12... the seed for this series was the number 60.
    Create a function that receives two integers: x, and y. If any of them are 0 or negative, or if
    they are greater than 255, the function should return -1.
    The function should return the y element of the series generated by x.
    For example: If the function receives x=60, y=3, it will return 20, because 20 is the 3th
    element in the series generated when x = 60.
    The function will receive 2 integers, return a floating point value.*/
    @org.junit.Test
    public void testEjercicio3() throws Exception {
        assertEquals(20.0, ejs.ejercicio3(60, 3),0.0f);
    }

    /*
    4. Remove strings? Piece of cake
    Given two strings S1 and S2. Delete from S1 all those characters which occur in S2. Return
    a clean S1 with the relevant characters deleted. Any character deletes both uppercase and
    lowercase.
    For example, given:
    S1 = “DevsuCodeJam is just great!”
    S2 = “I am here! :)”
    The function should return: “DvsuCodJsjustgt”.
    The function will receive 2 strings and return a string
    */
    @org.junit.Test
    public void testEjercicio4() throws Exception {
        assertEquals("DvsuCodJsjustgt", ejs.ejercicio4("DevsuCodeJam is just great!", "I am here! :)"));
    }

    /*
    5. Just One Line
    Write a function to remove duplicates from a sorted array of integers. Pretty easy, right?
    What about making it in one line of code? (You can use as many statements as needed, but
    the code should be written in one line).
    Example:
    If the function receives this array:
    A = [-3, -2, 0, 0, 5, 7, 9, 11, 11, 25]
    The function should return:
    A = [-3, -2, 0, 5, 7, 9, 11, 25]
    The function will receive an array of integers, and return an array of integers.
    */
    @org.junit.Test
    public void testEjercicio5() throws Exception {
        int[] entrada = {-3, -2, 0, 0, 5, 7, 9, 11, 11, 25};
        int[] salida =   {-3, -2, 0, 5, 7, 9, 11, 25};
        assertArrayEquals(salida, ejs.ejercicio5(entrada));
    }

    /*
    6.We want more!Given a string, which contains words and spaces (no special characters), create a function
    that return a string with the words in a reverse order.
            Example:
    If the function receives: “this is a test”, it should return: “test a is this”.
    If an empty string is received, an empty string should be returned. If only one word received,
    the same word should be returned.
    The function will receive a string and return a string.*/
    @org.junit.Test
    public void testEjercicio6() throws Exception {
        assertEquals("test a is this",ejs.ejercicio6("this is a test"));
        assertEquals("",ejs.ejercicio6(""));
        assertEquals("hola",ejs.ejercicio6("hola"));
    }

    /*7. Lowercase
    Given a string which contain letters (uppercase and lowercase), numbers, and special
    characters, return the same string in all lowercase.
    For example, if the function receives:
    “Ñañito, QUÉ bien! THIS is a sample text, Lorem Ipsum, 2 Be Converted.”
    The function should return:
    “ñañito, qué bien! this is a sample text, lorem ipsum, 2 be converted.”
    The function should consider converting: All characters from A-Z, Á,É,Í,Ó,Ú and Ñ. Other
    characters will remain the same.
    */
    @org.junit.Test
    public void testEjercicio7() throws Exception {
        String entrada = "Ñañito, QUÉ bien! THIS is a sample text, Lorem Ipsum, 2 Be Converted.";
        String salida = "ñañito, qué bien! this is a sample text, lorem ipsum, 2 be converted.";
        assertEquals(salida, ejs.ejercicio7(salida) );
    }

    /*8. A-Words
    Given a string, find the number of words that has at least one “a” character (uppercase or
    lowercase). Do not take into account character variations like á, à, etc... only the simple “a”
    and “A” counts.
    The words are always separated by a space, a comma, a semicolon or a dot.
    For example:
    If the function receives: “this is a sample text, it has a lot of analysis.” The function should
    return 5, since five words has “a” characters. (a, sample, has, a, analysis).
    The function will receive a string and return an integer.
    Limitations: Do not use the split() function, or similar.*/
    @org.junit.Test
    public void testEjercicio8() throws Exception {
        String entrada = "this is a sample text, it has a lot of analysis.";
        assertEquals(5, ejs.ejercicio8(entrada,'a') );
    }

    /*  9. The power of two
    Given a positive integer number determine if it’s the power of two of another integer.
    Don’t start coding, read the limitations.
    For example:
    If the function receives 25, it should return TRUE, because 5^2 = 25
    If the function receives 1, it should return TRUE, because 1^2 = 1
    If the function receives 16, it should return TRUE, because 4^2 = 16
    If the function receives 14, it should return FALSE.
    Limitation: You CAN’T use functions of square roots (sqrt() or similar), potentiation (pow()
    or similar). ONLY the basic arithmetic operations (sum, substraction, multiplication, division),
    and any logic operations are allowed.
    The function receives a positive integer greater than 0, and should return a boolean value.
    */
    @org.junit.Test
    public void testEjercicio9() throws Exception {
        assertEquals(true, ejs.ejercicio9(25) );
        assertEquals(true, ejs.ejercicio9(1) );
        assertEquals(true, ejs.ejercicio9(16) );
        assertEquals(false, ejs.ejercicio9(14) );
    }

    /*10. Perfect numbers
    A perfect number is a positive integer that is equal to the sum of its proper divisors. For
    example, 6 is a perfect number because 6=1+2+3.
    Create a function that receives two values X and Y and return the smaller perfect number
    found, which is greater or equal than X and lower or equal than Y. If no perfect number
    found, it should return -1.
    For example, if the function receives X=5, Y=7, it should return 6, because 6 is the smaller
    perfect number between 5 and 7.
    The function will receive two integers and return one integer.*/
    @org.junit.Test
    public void testEjercicio10() throws Exception {

        assertEquals(6, ejs.ejercicio10(5,7) );
        assertEquals(496, ejs.ejercicio10(400, 500) );
        assertEquals(8128, ejs.ejercicio10(5000,9000) );
        assertEquals(-1, ejs.ejercicio10(14,21) );
    }

    /*
    11. Counter
    Given an array of integers, find which is repeated more times. Return the number that
    has more repetitions. If two numbers has the same amount of repetitions, return the lower
    number.
    For example, given this array:
    A = [1, 5, 3, -2, 4, 2, 4, -2, 5, 5, 2, 1, 3]
            1 is repeated 2 times
    5 is repeated 3 times
    3 is repeated 2 times
    -2 is once
    4 is repeated 2 times
    2 is repeated 2 times
    The most repeated number is 5. The function should return: 5. (Because 5 is repeated 3
    times in the array).
    The function will receive an array of integers and return an integer
    */
    @org.junit.Test
    public void testEjercicio11() throws Exception {
        int[] a = {1, 5, -2,3,4, 2, 4, -2, 5, 5, 2, 1, 3};
        assertEquals(5, ejs.ejercicio11(a) );
        int[] b = {1, -2,4,4,4};
        assertEquals(4, ejs.ejercicio11(b) );
        int[] c = {1, -2,4,4,4,-2,-2,3,-2};
        assertEquals(-2, ejs.ejercicio11(c) );
        int[] d = {1,4,4,4,-2,-2,3,-2};
        assertEquals(-2, ejs.ejercicio11(d) );
    }

    /*
    12. The last piece of cake
    Equilibrium index of a sequence is an index such that the sum of elements at lower indexes
    is equal to the sum of elements at higher indexes.
    Create a function that receives an array of integers and returns the first equilibrium index
    found. If no equilibrium index found, the function should return -1
    For example, if the array received is:
    A=[-7, 1, 5, 2, -4, 3, 0]
            3 is an equilibrium index, because:
    A[0]+A[1]+A[2] = A[4]+A[5]+A[6]
    In other words, you should find the index of the array where the sum of the left elements is
    equal to the sum of the right elements.
    In the example, the function will return 3, because it’s the first equilibrium index found in the
    array.
    The function receives an array of integers and return an integer.
    */
    @org.junit.Test
    public void testEjercicio12() throws Exception {
        int[] a = {-7, 1, 5, 2, -4, 3, 0};
       // int[] a = {-7, 1,-7};
        assertEquals(3, ejs.ejercicio12(a) );

        int[] b = {-7, -65,-1,-1,-5};
        assertEquals(1, ejs.ejercicio12(b) );

        int[] c = {1, -2,4,4,4,-2,-2,3,7};
        assertEquals(7, ejs.ejercicio12(c) );
        int[] d = {1,2,3,4,5};
        assertEquals(-1, ejs.ejercicio12(d) );
    }

    /*
    13. Something easy...
    You are given an array with positive and negative integers. Write a function to change the
    elements order in the array such that negative integers are at the beginning, the positive
    integers are at the end. Zero (0) and integers that have the same sign don't change order.
    For example, if the function receives:
    a[0] = 4;
    a[1] = -3;
    a[2] = -100;
    a[3] = 7;
    a[4] = 0;
    a[5] = 1;
    a[6] = -6;
    the function should return:
    a[0] = -3;
    a[1] = -100;
    a[2] = -6;
    a[3] = 4;
    a[4] = 7;
    a[5] = 0;
    a[6] = 1;
    The function receives an array of integers and return an array of integers.
    Limitations:
    You CAN’T use sorting methods provided by the language. (eg. Array.sort(), sort(), etc...). If
    you need to, you should create your own implementation of the sorting function.*/

    @org.junit.Test
    public void testEjercicio13() throws Exception {
        int[] a = { 4,-3, -100,7,0,1,-6};
        int[] ab = {-3,-100,-6,4,7,0, 1 };

        assertArrayEquals(ab, ejs.ejercicio13(a));
    }

    /*
    14. Okay, okay okay, … is this a programming contest or a “series” test?
    Look at this series: 53, 35, 64, 46, 75, 57, 86, 68, 97, 79, 108, 810, 119, 911, 1210, 1012, …
    the seeds for this series were the numbers 5 and 3.
    Look at this series: 103, 310, 114, 411, 125, 512, 136, 613, 147, 714, 158, 815, 169, 916,
            1710, 1017, … the seeds for this series were the numbers 10 and 3.
    Look at this series: 1012, 1210, 1113, 1311, 1214, 1412, 1315, 1513, 1416, 1614, 1517,
            1715, 1618, 1816, 1719, 1917, … the seeds for this series were the numbers 10 and 12.
    Create a function that receives three integers: x, y and z. If any of them are 0 or negative, or
    if they are greater than 255, the function should return -1
    The function should return the z element of the series generated by x and y.
    For example: If the function receives x=5, y=3, z=3, it will return 64, because 64 is the 3th
    element in the generated series when x=5 and y=3.
    A (big) clue: The second number is just the first number, with it’s parts inverted; the fourth
    number is just the third number, with it’s parts inverted, and so forth...
    The function will receive 3 integers, return an integer.*/



    @org.junit.Test
    public void testEjercicio14() throws Exception {


        assertEquals(64, ejs.ejercicio14(5, 3, 3));
        assertEquals(46, ejs.ejercicio14(5, 3, 4));

        assertEquals(114, ejs.ejercicio14(10, 3, 3));
        assertEquals(1315, ejs.ejercicio14(10, 12, 7));
    }

    /*
    15. Contiguous subarrays
    Given an array of integers (positive and negative), find the contiguous subarray with the
    largest sum. Return the sum.
    The subarray can be of any length, even it could be the whole array. It could be also a single
    element.
    For example:
    If the function receives the following array:
    A=[4, -3, 7, 2, 4, -5, 1, 2]
    Some contiguous subarrays are:
    Subarray from index 0 to 1: [4, -3] sums 1
    Subarray from index 2 to 4: [7, 2, 4] sums 13
    Subarray from index 0 to 7: [4, -3, 7, 2, 4, -5, 1, 2] sums 12
    Subarray from index 0 to 0: [4] sums 4
            ….
            [4, 7, 2, 4] is NOT a contiguous subarray.
    The function will find that the contiguous subarray with the largest sum is [4, -3, 7, 2, 4],
    which sums 14. The function should return 14.
    */
    @org.junit.Test
    public void testEjercicio15() throws Exception {
        int[] a = {4, -3, 7, 2, 4, -5, 1, 2};
        assertEquals(14, ejs.ejercicio15(a));
    }

    /*
    16. Series again
    Look at this series: 3, 6, 24, 144, … the seed for this series was the number 3.
    Look at this series: 8, 16, 64, 384, … the seed for this series was the number 8.
    Create a function that receives three integers: x, y and z. If any of them are 0 or negative, or
    if they are greater than 255, the function should return -1
    This function should return a value calculated based on y and z from the series generated by
    x. (x is the seed for the series).
    For example, if the function receives x = 3, y = 1, z = 3, the function will find (based on x),
    that the series is 3, 6, 24, 144, …, based on that series, and based on y=1 and z=3, the
    function should return 33.
    If the function receives x = 8, y = 2, z = 4, the function should return 464. If the function
    receives x = 5, y = 2, z = 2, the function should return 10. For any case where y > z, the
    function will return 0.
    To find the relationship between y, z and the result is part of the problem to be resolved.
    The function will receive 3 integers, and return an integer.
    */
    @org.junit.Test
    public void testEjercicio16() throws Exception {
        assertEquals(33, ejs.ejercicio16(3,1,3));
    }

}